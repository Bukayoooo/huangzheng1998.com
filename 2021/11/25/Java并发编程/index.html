<!DOCTYPE html><html lang="en | zh-CN |zh-TW" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java并发编程 | Patterson</title><meta name="keywords" content="编程"><meta name="author" content="Patterson"><meta name="copyright" content="Patterson"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 多线程1 多线程基础从软件和硬件上实现多个进程并发执行的技术，具有多线程能力的计算机由于硬件的支持进而可以同一时间执行多个线程，提升程序运行效率​ 并发与并行​ 并发：同一时刻，多条指令在CPU上交替执行​ 并行：同一时刻，多条指令在CPU上同时执行​ 进程与线程​ 进程：进程指正在运行的程序。程序是由指令和数据组成的，指令需要运行，数据需要读写，必须将指令加载值CPU，数据加载至内存；指令">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发编程">
<meta property="og:url" content="http://huangzheng1998.com/2021/11/25/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Patterson">
<meta property="og:description" content="1. 多线程1 多线程基础从软件和硬件上实现多个进程并发执行的技术，具有多线程能力的计算机由于硬件的支持进而可以同一时间执行多个线程，提升程序运行效率​ 并发与并行​ 并发：同一时刻，多条指令在CPU上交替执行​ 并行：同一时刻，多条指令在CPU上同时执行​ 进程与线程​ 进程：进程指正在运行的程序。程序是由指令和数据组成的，指令需要运行，数据需要读写，必须将指令加载值CPU，数据加载至内存；指令">
<meta property="og:locale">
<meta property="og:image" content="http://huangzheng1998.com/imgcat/java.png">
<meta property="article:published_time" content="2021-11-25T11:31:20.000Z">
<meta property="article:modified_time" content="2022-02-26T09:08:34.787Z">
<meta property="article:author" content="Patterson">
<meta property="article:tag" content="编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://huangzheng1998.com/imgcat/java.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://huangzheng1998.com/2021/11/25/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java并发编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-26 17:08:34'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/b.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">35</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">8</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></div><div class="menus_item"><a class="site-page" href="/musics/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/imgcat/java.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Patterson</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></div><div class="menus_item"><a class="site-page" href="/musics/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java并发编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-11-25T11:31:20.000Z" title="Created 2021-11-25 19:31:20">2021-11-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-02-26T09:08:34.787Z" title="Updated 2022-02-26 17:08:34">2022-02-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java并发编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-多线程"><a href="#1-多线程" class="headerlink" title="1. 多线程"></a>1. 多线程</h1><h2 id="1-多线程基础"><a href="#1-多线程基础" class="headerlink" title="1 多线程基础"></a>1 <strong>多线程基础</strong></h2><p>从软件和硬件上实现多个进程并发执行的技术，具有多线程能力的计算机由于硬件的支持进而可以同一时间执行多个线程，提升程序运行效率<br>​</p>
<p><strong>并发与并行</strong><br>​</p>
<p><strong>并发</strong>：同一时刻，多条指令在CPU上交替执行<br>​</p>
<p><strong>并行</strong>：同一时刻，多条指令在CPU上同时执行<br>​</p>
<p><strong>进程与线程</strong><br>​</p>
<p><strong>进程</strong>：进程指正在运行的程序。程序是由指令和数据组成的，指令需要运行，数据需要读写，必须将指令加载值CPU，数据加载至内存；指令运行过程中还需要用到磁盘，网络等设备。进程是用来加载指令，管理内存，管理IO的。<br>​</p>
<pre><code>进程特性：
</code></pre><ul>
<li>独立性：进程是一个独立运行的基本单位，是用来分配系统资源和调度的单位</li>
<li>动态性：进程的产生就是程序的一次执行，进程是伴随着程序执行动态产生，动态消亡的</li>
<li>并发性：任何进程都可以与其他进程一起并发执行</li>
</ul>
<p><strong>线程</strong>：进程中的顺序控制流，是一条执行路径。一个进程之内可以分为多个线程，线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行。Java中，线程为最小调度单位，进程作为资源分配的最小单位。Windows中进程是不活动的，只是作为线程的容器。<br>​</p>
<ul>
<li>单线程：如果一个进程只有一条执行路径，则称之为单线程程序</li>
<li>多线程：如果一个进程由多条执行路径，则称之为多线程程序</li>
</ul>
<p><strong>进程与线程的对比</strong><br>​</p>
<ul>
<li>进程基本是相互独立的，线程存在于进程内，属于进程的子集；进程拥有共享的资源(内存空间)，由其内部的线程共享。</li>
<li>进程间的通信较为复杂，同一台计算机的进程间通信称为IPC；不同计算机之间的通信需要通过网络，并且最受共同的网络协议，如HTTP协议。</li>
<li>线程间的通信相对简单，因为线程间共享进程内的内存。多个线程可以访问同一个共享变量，线程更加的轻量，线程的上下文切换成本一般比进程的上下文切换低。</li>
</ul>
<p><strong>进程和线程的切换</strong><br>​</p>
<p><strong>上下文切换</strong>：系统内核为每一个进程维持一个上下文。<strong>上下文是内核重新启动一个被抢占的进程所需要的状态，</strong>包括通用目的寄存器、浮点寄存器、程序计数器、状态寄存器、用户栈、内核栈和各种内核数据结构。<br>​</p>
<p><strong>进程切换与线程切换的区别：</strong>进程的切换会涉及到虚拟地址空间的切换，因为每个进程都有自己的虚拟空间地址，而线程是共享进程的虚拟空间地址，所以线程的切换不会设计到虚拟空间地址的切换<br>​</p>
<h2 id="2-多线程的实现"><a href="#2-多线程的实现" class="headerlink" title="2 多线程的实现"></a>2 多线程的实现</h2><h3 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1. 继承Thread类"></a>1. <strong>继承Thread类</strong></h3><ul>
<li>定义一个MyThread类继承Thread类，重写run方法，run方法里封装被线程执行的代码</li>
<li>创建MyThread对象，调用start方法，Java虚拟机会调用此线程的run方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_01</span>多线程实现方式一</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        MyThread t2 = <span class="keyword">new</span> MyThread();</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2. 实现Runnable接口"></a>2. 实现Runnable接口</h3><ul>
<li>定义一个MyRunnable类实现Runnalbe接口，重写Runnable接口</li>
<li>创建MyRunnable对象，将该对象作为参数传递给线程对象Thread</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_02</span>多线程实现方式二</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">				System.out.println(Thread.currentThread()</span><br><span class="line">                                   .getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyRunnable mr = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(mr, <span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(mr, <span class="string">&quot;线程2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-实现callable接口"><a href="#3-实现callable接口" class="headerlink" title="3. 实现callable接口"></a>3. 实现callable接口</h3><ul>
<li>定义MyCallable实现Callable接口，重写call方法，call方法中封装线程执行的方法</li>
<li>创建MyCallable对象，将其作为参数传入一个新建的FutureTask对象中</li>
<li>使用FutureTask对象的get方法，可以获得线程执行完成返回的数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">				System.out.println(Thread.currentThread()</span><br><span class="line">                                   .getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;线程执行完毕&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        MyCallable mc = <span class="keyword">new</span> MyCallable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// FutureTask可以获得线程执行完毕的结果，也可以作为参数		传递给Thread</span></span><br><span class="line">        FutureTask&lt;String&gt; ft1 = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line">        FutureTask&lt;String&gt; ft2 = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(ft1, <span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(ft2, <span class="string">&quot;线程2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        System.out.println(ft1.get());</span><br><span class="line">        System.out.println(ft2.get());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-线程运行原理"><a href="#3-线程运行原理" class="headerlink" title="3 线程运行原理"></a>3 线程运行原理</h2><p><strong>栈与栈帧</strong><br>​</p>
<ul>
<li>每个线程启动后，Java虚拟机栈会为其分配一块栈内存</li>
<li>每个栈由多个栈帧构成，对应着方法调用时占用的内存</li>
</ul>
<p><strong>线程上下文切换</strong><br>​</p>
<pre><code>**Thread Context Switch:** 因为一些原因导致CPU不再执行当前的线程，转而去执行另一个线程的代码，原因如下：
</code></pre><ul>
<li>CPU为线程分配的时间片用完</li>
<li>垃圾回收线程或者有更高优先级的线程需要运行</li>
<li>线程自身调用了sleep、yield、join、wait、park、synchronized、lock等方法</li>
</ul>
<p>当线程上下文切换发生时，需要操作系统保存当前线程的状态，并恢复另一个线程的状态，即通过程序计数器PC中保存的jvm指令执行地址来恢复，PC是线程私有的<br>​</p>
<ul>
<li>保存的状态包括程序计数器、虚拟机栈的栈帧信息，局部变量表、操作数栈、方法返回地址等</li>
<li>频繁的线程上下文切换会影响程序执行的性能</li>
</ul>
<h2 id="4-多线程方法"><a href="#4-多线程方法" class="headerlink" title="4 多线程方法"></a>4 多线程方法</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a><strong>API</strong></h3><div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public void run()</td>
<td>线程启动后调用该方法</td>
</tr>
<tr>
<td>public void setName(String name)</td>
<td>给当前线程取名字</td>
</tr>
<tr>
<td>public void getName()</td>
<td>获取当前线程的名字</td>
</tr>
</tbody>
</table>
</div>
<p>线程存在默认名称：子线程是Thread-索引，主线程是main |<br>| public void start() | 启动一个新线程；Java虚拟机调用此线程的run方法 |<br>| public static Thread currentThread() | 获取当前线程对象，代码在哪个线程中执行 |<br>| public static void sleep(long time) | 让当前线程休眠多少毫秒再继续执行<br><strong>Thread.sleep(0)</strong> : 让操作系统立刻重新进行一次cpu竞争 |<br>| public static native void yield() | 提示线程调度器让出当前线程对CPU的使用 |<br>| public final int getPriority() | 返回此线程的优先级 |<br>| public final void setPriority(int priority) | 更改此线程的优先级，常用1 5 10 |<br>| public void interrupt() | 中断这个线程，异常处理机制 |<br>| public static boolean interrupted() | 判断当前线程是否被打断，清除打断标记 |<br>| public boolean isInterrupted() | 判断当前线程是否被打断，不清除打断标记 |<br>| public final void join() | 等待这个线程结束 |<br>| public final void join(long millis) | 等待这个线程死亡millis毫秒，0意味着永远等待 |<br>| public final native boolean isAlive() | 线程是否存活（还没有运行完毕） |<br>| public final void setDaemon(boolean on) | 将此线程标记为守护线程或用户线程 |</p>
<h3 id="start-run"><a href="#start-run" class="headerlink" title="start run"></a><strong>start run</strong></h3><p>被创建的Thread对象直接调用重写的run方法时， run方法是在<strong>主线程</strong>中被执行的，而不是在我们所创建的线程中执行。所以如果想要在所创建的线程中执行run方法，<strong>需要使用Thread对象的start方法。</strong><br>​</p>
<h3 id="sleep-yield-wait"><a href="#sleep-yield-wait" class="headerlink" title="sleep  yield  wait"></a><strong>sleep  yield  wait</strong></h3><p><strong>sleep():</strong> 用于使线程阻塞，线程从Running状态进入Timed Waiting状态(阻塞状态)；使用<strong>interrupt</strong>方法可以打断正在运行的线程，sleep方法会抛出InterruptedException；睡眠结束的线程未必会立即执行，需要重新和其他线程竞争获取CPU时间片！<br>​</p>
<p><strong>yield():</strong>用于退出当前线程，线程从Running状态进入Runnable状态；然后系统调度执行其他线程。<br>​</p>
<p><strong>wait():</strong> 锁对象的方法，用于等待其他线程传来的数据，线程处于阻塞状态。<br>​</p>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a><strong>join</strong></h3><p><strong>join()：</strong>用于等待某个线程结束，线程处于阻塞状态；如在主线程中调用t1.join()，主线程会等待t1线程结束才会继续执行。<br>​</p>
<h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a><strong>interrupt</strong></h3><p><strong>interrupt()：</strong>用于打断处于阻塞状态的线程(sleep, wait, join)。<br>​</p>
<ul>
<li>如果一个线程在在运行中被打断，打断标记会被置为true。</li>
<li>如果是打断因sleep wait join方法而被阻塞的线程，会将打断标记置为false</li>
</ul>
<p><strong>interrupt方法应用：优雅的打断其他线程</strong><br>​</p>
<p>两阶段终止模式：见<br>​</p>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p><strong>线程调度方式</strong><br>​</p>
<ul>
<li>分时调度模型：所线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片</li>
<li>抢占式调度模型：优先让优先级高的线程使用CPU，如果优先级相同，随机一个线程抢占时间片，优先级高的线程获得的CPU时间片多一些。Java使用的是抢占式调度模型</li>
</ul>
<p><strong>final int getPriority()</strong> : 返回此线程的优先级<br>​</p>
<p><strong>final void setPriority(int newPriority)</strong>: 更改此线程的优先级线程默认优先级是5；线程优先级的 范围是：1-10<br>​</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p><strong>void setDaemon(boolean on)</strong>: 将此线程标记为守护线程，当运行的线程都是守护线程 时，Java虚拟机将退出<br>​</p>
<h2 id="5-线程状态"><a href="#5-线程状态" class="headerlink" title="5 线程状态"></a>5 线程状态</h2><h3 id="操作系统五种线程状态"><a href="#操作系统五种线程状态" class="headerlink" title="操作系统五种线程状态"></a>操作系统五种线程状态</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25887408/1642076257767-2a92179a-b460-4b6d-a5a1-8d150abc88be.png#clientId=uef69f355-6ec7-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=ui&amp;id=u4284d5b2&amp;margin=%5Bobject%20Object%5D&amp;name=%E7%BA%BF%E7%A8%8B%E4%BA%94%E7%A7%8D%E7%8A%B6%E6%80%81.png&amp;originHeight=557&amp;originWidth=849&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=56957&amp;status=done&amp;style=none&amp;taskId=u8a408214-a726-4798-b147-dedef0d0503&amp;title=" alt="线程五种状态.png"><br>​</p>
<ul>
<li>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联（例如线程调用了start方法）</li>
<li>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</li>
<li>【运行状态】指获取了 CPU 时间片运行中的状态 <ul>
<li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li>
</ul>
</li>
<li>【阻塞状态】 <ul>
<li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入 【阻塞状态】</li>
<li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li>
<li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</li>
</ul>
</li>
<li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li>
</ul>
<h3 id="Java六种线程状态"><a href="#Java六种线程状态" class="headerlink" title="Java六种线程状态"></a>Java六种线程状态</h3><p>线程由生到死的完整过程（生命周期）：当线程被创建并启动以后，既不是一启动就进入了执行状态，也不是一直处于执行状态，在 API 中 <code>java.lang.Thread.State</code> 这个枚举中给出了六种线程状态：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>线程状态</th>
<th>导致状态发生条件</th>
</tr>
</thead>
<tbody>
<tr>
<td>NEW（新建）</td>
<td>线程刚被创建，但是并未启动，还没调用 start 方法，只有线程对象，没有线程特征</td>
</tr>
<tr>
<td>Runnable（可运行）</td>
<td>线程可以在 Java 虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器，调用了 t.start() 方法：就绪（经典叫法）</td>
</tr>
<tr>
<td>Blocked（锁阻塞）</td>
<td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入 Blocked 状态；当该线程持有锁时，该线程将变成 Runnable 状态</td>
</tr>
<tr>
<td>Waiting（无限等待）</td>
<td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入 Waiting 状态，进入这个状态后不能自动唤醒，必须等待另一个线程调用 notify 或者 notifyAll 方法才能唤醒</td>
</tr>
<tr>
<td>Timed Waiting （计时等待）</td>
<td>有几个方法有超时参数，调用将进入 Timed Waiting 状态，这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有 Thread.sleep 、Object.wait</td>
</tr>
<tr>
<td>Teminated（被终止）</td>
<td>run 方法正常退出而死亡，或者因为没有捕获的异常终止了 run 方法而死亡</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/25887408/1642076311193-432d22da-1667-40f0-95fb-82583254d11e.png#clientId=uef69f355-6ec7-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=ui&amp;id=uc3317a82&amp;margin=%5Bobject%20Object%5D&amp;name=%E7%BA%BF%E7%A8%8B%E5%85%AD%E7%A7%8D%E7%8A%B6%E6%80%81.png&amp;originHeight=531&amp;originWidth=1079&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=110195&amp;status=done&amp;style=none&amp;taskId=u6cd3d91d-ace5-4404-9426-74313398085&amp;title=" alt="线程六种状态.png"><br>ps: Java里的RUNNABLE状态中是包含阻塞状态的(不是指BLOCKED，它特指竞争锁失败的状态)，如拷贝文件时使用<strong>阻塞IO</strong>，此时线程不使用CPU，但需要一直等待IO结束，此时线程就处于RUNNABLE的阻塞状态。<br>​</p>
<p>情况一：NEW –&gt; RUNNABLE<br>​</p>
<ul>
<li>当调用了t.start()方法时，由 NEW –&gt; RUNNABLE</li>
</ul>
<p>情况二： RUNNABLE &lt;–&gt; WAITING<br>​</p>
<ul>
<li>当调用了t 线程用 synchronized(obj) 获取了对象锁后 <ul>
<li>调用 obj.wait() 方法时，t 线程从 RUNNABLE –&gt; WAITING</li>
<li>调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时 <ul>
<li>竞争锁成功，t 线程从 WAITING –&gt; RUNNABLE</li>
<li>竞争锁失败，t 线程从 WAITING –&gt; BLOCKED</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>情况三：RUNNABLE &lt;–&gt; WAITING<br>​</p>
<ul>
<li>当前线程<br>调用 t.join() 方法时，当前线程从 RUNNABLE –&gt; WAITING <ul>
<li>注意是<strong>当前线程</strong>在t 线程对象的监视器上等待</li>
</ul>
</li>
<li>t 线程<strong>运行结束</strong>，或调用了<strong>当前线程</strong>的 interrupt() 时，当前线程从 WAITING –&gt; RUNNABLE </li>
</ul>
<p>情况四： RUNNABLE &lt;–&gt; WAITING<br>​</p>
<ul>
<li>当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE –&gt; WAITING</li>
<li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING –&gt; RUNNABLE</li>
</ul>
<p>情况五： RUNNABLE &lt;–&gt; TIMED_WAITING<br>​</p>
<p>t 线程用 synchronized(obj) 获取了对象锁后<br>​</p>
<ul>
<li>调用 obj.wait(<strong>long n</strong>) 方法时，t 线程从 RUNNABLE –&gt; TIMED_WAITING</li>
<li>t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时 <ul>
<li>竞争锁成功，t 线程从 TIMED_WAITING –&gt; RUNNABLE</li>
<li>竞争锁失败，t 线程从 TIMED_WAITING –&gt; BLOCKED</li>
</ul>
</li>
</ul>
<p>情况六：RUNNABLE &lt;–&gt; TIMED_WAITING<br>​</p>
<ul>
<li>当前线程调用 t.join<br>(long n<br>) 方法时，当前线程从 RUNNABLE –&gt; TIMED_WAITING <ul>
<li>注意是当前线程在t 线程对象的监视器上等待</li>
</ul>
</li>
<li>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 TIMED_WAITING –&gt; RUNNABLE </li>
</ul>
<p>情况七：RUNNABLE &lt;–&gt; TIMED_WAITING<br>​</p>
<ul>
<li>当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE –&gt; TIMED_WAITING</li>
<li>当前线程等待时间超过了 n 毫秒，当前线程从 TIMED_WAITING –&gt; RUNNABLE</li>
</ul>
<p>情况八：RUNNABLE &lt;–&gt; TIMED_WAITING<br>​</p>
<ul>
<li>当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线 程从 RUNNABLE –&gt; TIMED_WAITING</li>
<li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从 TIMED_WAITING–&gt; RUNNABLE</li>
</ul>
<p>情况九：RUNNABLE &lt;–&gt; BLOCKED<br>​</p>
<ul>
<li>t 线程用 synchronized(obj) 获取了对象锁时如果<strong>竞争失败</strong>，从 RUNNABLE –&gt; BLOCKED</li>
<li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争 成功，从 BLOCKED –&gt; RUNNABLE ，其它<strong>失败</strong>的线程仍然 BLOCKED</li>
</ul>
<p>情况十： RUNNABLE &lt;–&gt; TERMINATED<br>​</p>
<ul>
<li>当前线<strong>程所有代码运行完毕</strong>，进入 TERMINATED</li>
</ul>
<h1 id="2-管程"><a href="#2-管程" class="headerlink" title="2.管程"></a>2.管程</h1><h2 id="1-线程安全问题"><a href="#1-线程安全问题" class="headerlink" title="1 线程安全问题"></a>1 线程安全问题</h2><p>线程安全问题：根本原因是多线程的上下文切换，导致当前线程中的指令没有执行完就切换执行其他线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_01ThreadSafty</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">       </span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++)&#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">&quot;count的值为&#123;&#125;&quot;</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">打印信息：count的值不为0</span><br><span class="line">16:46:12.488 h._01ThreadSafty02 [main] - count的值为77</span><br></pre></td></tr></table></figure><br>这是因为count++自增与count—自减都不是原子操作<br>分成以下四个原子操作<br><img src="https://cdn.nlark.com/yuque/0/2022/png/25887408/1642840923432-572fc1aa-6562-4d41-8e9c-1df2fcc23ccf.png#clientId=uc4923773-e91c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=107&amp;id=u0bbfff4b&amp;name=image.png&amp;originHeight=107&amp;originWidth=546&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=18677&amp;status=done&amp;style=none&amp;taskId=u7aed63b0-d29c-47a5-b6d5-48d35fe2b3d&amp;title=&amp;width=546" alt="image.png"><br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getstatic i 	// 获取静态变量i的值</span><br><span class="line">iconst_1 			// 准备常量<span class="number">1</span></span><br><span class="line">iadd 					// 自增</span><br><span class="line">putstatic i 	// 将修改后的值存入静态变量i</span><br><span class="line">    </span><br><span class="line">getstatic i 	// 获取静态变量i的值</span><br><span class="line">iconst_1 			// 准备常量<span class="number">1</span></span><br><span class="line">isub 					// 自减</span><br><span class="line">putstatic i 	// 将修改后的值存入静态变量i</span><br></pre></td></tr></table></figure></p>
<ul>
<li>可以看到count++ 和 count— 操作实际都是需要这个4个指令完成的，那么这里问题就来了！Java 的内存模型如下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换：</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/25887408/1642841727593-bb0953e1-066d-4a21-9093-9e2a8d05378a.png#clientId=uc4923773-e91c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u9c672df8&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=200&amp;originWidth=511&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=35364&amp;status=done&amp;style=none&amp;taskId=u8ad86022-e822-4af7-9ecf-b9e935e6183&amp;title=" alt="image.png"><br> 如果代码按照下面左图正常的顺序执行，count的值是不会计算出错的，而右图中两个线程间发生了上下文切换，两个线程操作共享变量i<br>导致i的计算出现了错误，产生了线程安全问题<br><img src="https://cdn.nlark.com/yuque/0/2022/png/25887408/1642842998105-8dc06f9c-7072-4d21-8593-bfff1f372b2c.png#clientId=uc4923773-e91c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=ui&amp;id=u8cd953f8&amp;margin=%5Bobject%20Object%5D&amp;name=%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20%285%29.png&amp;originHeight=991&amp;originWidth=1296&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=99419&amp;status=done&amp;style=none&amp;taskId=uc43be312-6a54-4d10-81e4-99b3a159c3e&amp;title=" alt="未命名文件 (5).png"></p>
<ol>
<li><strong>临界区</strong></li>
</ol>
<ul>
<li><strong>多个线程访问共享资源时会出现问题</strong><ul>
<li>多个线程对共享资源进行读操作时不会出现问题</li>
<li>在多个线程对共享变量进行写操作时，可能会发生指令交错，就会出现线程安全问题</li>
</ul>
</li>
<li>一段代码如果存在对共享资源的多线程读写操作，这段代码称之为临界区<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 临界区 </span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    counter++; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 临界区 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    counter--; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><strong>竞态条件</strong></li>
</ol>
<ul>
<li>多个线程在临界区执行，由于指令执行的顺序不确定造成运行结果不确定的问题，称为竞态条件<h2 id="2-synchronized"><a href="#2-synchronized" class="headerlink" title="2 synchronized"></a>2 synchronized</h2></li>
</ul>
<p>为了避免临界区中竞态条件的发生，可以使用多种手段达到</p>
<ul>
<li><strong>阻塞式解决方案：synchronized, lock (ReentrantLock)</strong></li>
<li><strong>非阻塞式解决方案：原子变量CAS</strong></li>
</ul>
<p>synchronized即俗称的<strong>对象锁</strong>，它采用<strong>互斥</strong>的方式使得同一时刻下至多有一个线程拥有对象锁，<strong>其他线程若想获得对象锁就会被阻塞住</strong>，这样就可以使得拥有锁的线程可以安全的执行临界区中的代码，<strong>不用担心发生线程上下文切换</strong></p>
<h3 id="2-1-synchronized语法"><a href="#2-1-synchronized语法" class="headerlink" title="2.1 synchronized语法"></a>2.1 synchronized语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line"> 	<span class="comment">// 临界区   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述案例使用synchronized加锁，既可以解决线程安全问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_01ThreadSafty</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (_01ThreadSafty.class)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (_01ThreadSafty.class)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++)&#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">&quot;count的值为&#123;&#125;&quot;</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">打印信息：count的值为0</span><br><span class="line">18:09:03.621 h._01ThreadSafty [main] - count的值为0</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-synchronized原理"><a href="#2-2-synchronized原理" class="headerlink" title="2.2 synchronized原理"></a>2.2 synchronized原理</h3><ul>
<li>synchronized利用对象锁保证了临界区代码的原子性，临界区的代码在外界看来是不可分割的，不会被线程切换所打断</li>
</ul>
<p>上述加锁代码执行逻辑<br><img src="https://cdn.nlark.com/yuque/0/2022/png/25887408/1642849062564-493ff991-1892-420e-95de-9369f2449200.png#clientId=uc4923773-e91c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=ui&amp;id=ud92414e7&amp;margin=%5Bobject%20Object%5D&amp;name=%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20%286%29.png&amp;originHeight=1393&amp;originWidth=919&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=106209&amp;status=done&amp;style=none&amp;taskId=u9fd2ed55-ed68-412d-bb53-bb77efa7db8&amp;title=" alt="未命名文件 (6).png"></p>
<ul>
<li>当多个线程对临界资源进行写操作时，或出现线程安全问题</li>
<li>使用synchronized关键字，使得多个线程共有一个对象锁可以避免竞态条件的发生<h3 id="2-3-synchronized加在方法上"><a href="#2-3-synchronized加在方法上" class="headerlink" title="2.3 synchronized加在方法上"></a>2.3 synchronized加在方法上</h3></li>
</ul>
<ol>
<li><p>synchronized加在实例方法上，锁对象就是实例对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="comment">// synchronized加在实例方法上</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等价于</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;    </span><br><span class="line">        	...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>synchronized加在静态方法上，锁对象就是当前列的Class实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="comment">// synchronized加在实例方法上</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等价于</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">synchronized</span>(Demo.class)&#123;    </span><br><span class="line">        	...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-线程安全分析"><a href="#3-线程安全分析" class="headerlink" title="3 线程安全分析"></a>3 线程安全分析</h2><h3 id="3-1-成员变量与静态变量的线程安全分析"><a href="#3-1-成员变量与静态变量的线程安全分析" class="headerlink" title="3.1 成员变量与静态变量的线程安全分析"></a>3.1 成员变量与静态变量的线程安全分析</h3></li>
</ol>
<ul>
<li>如果变量没有在线程间共享，变量则是线程安全的</li>
<li><p>如果变量在线程间共享</p>
<ul>
<li>如果线程内只有读操作，则是线程安全的</li>
<li>如果线程内有读写操作，则需要考虑线程安全<h3 id="3-2-局部变量线程安全分析"><a href="#3-2-局部变量线程安全分析" class="headerlink" title="3.2 局部变量线程安全分析"></a>3.2 局部变量线程安全分析</h3>局部变量被存储在栈帧内</li>
</ul>
</li>
<li><p>如果局部变量被初始化为基本数据类型，则是线程安全的</p>
</li>
<li><p>如果局部变量被初始化为引用对象，则可能引发线程安全问题</p>
<ul>
<li>如果引用对象没有逃离方法的作用范围，则引用对象是线程安全的</li>
<li>如果引用对象逃离方法的作用范围，则需要考虑线程安全问题<h3 id="3-3-线程安全的情况"><a href="#3-3-线程安全的情况" class="headerlink" title="3.3 线程安全的情况"></a>3.3 线程安全的情况</h3></li>
</ul>
</li>
<li><p>局部变量存储于栈帧中，虚拟机栈是线程私有的</p>
</li>
<li><p>如果局部变量被初始化为基本数据类型，则是线程安全的，示例如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i=<span class="number">10</span>;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程调用test01方法时，会在每个线程中分别创建栈帧，所以变量i存在于多个不同的栈内存，因此不存在变量的共享<br><img src="https://cdn.nlark.com/yuque/0/2022/png/25887408/1642857004552-b71ef38e-9c0c-46b9-8350-d2c481406071.png#clientId=u23f207af-aa6c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u79f56c60&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=629&amp;originWidth=670&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=130133&amp;status=done&amp;style=none&amp;taskId=u8263cc83-15de-4696-b765-ad28236445f&amp;title=" alt="image.png"></p>
<h3 id="3-4-线程不安全的情况"><a href="#3-4-线程不安全的情况" class="headerlink" title="3.4 线程不安全的情况"></a>3.4 线程不安全的情况</h3><ul>
<li>如果引用对象逃离方法的作用范围，则需要考虑线程安全问题<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;h.UnsafeTest&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeTest</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method01</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">			method02();</span><br><span class="line">			method03();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">method02</span><span class="params">()</span></span>&#123;</span><br><span class="line">		arrayList.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">method03</span><span class="params">()</span></span>&#123;</span><br><span class="line">		arrayList.add(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;h.ThreadUnSafty&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadUnSafty</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		method();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">		UnsafeTest unsafeTest = <span class="keyword">new</span> UnsafeTest();</span><br><span class="line">		<span class="comment">// 创建100个线程</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">				unsafeTest.method01();</span><br><span class="line">			&#125;, <span class="string">&quot;线程&quot;</span> + i).start();</span><br><span class="line">		&#125;</span><br><span class="line">		Sleep.sleep(<span class="number">100</span>);</span><br><span class="line">		System.out.println(unsafeTest.arrayList.size());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsafeTest.arrayList.size == 19773 </span><br><span class="line">线程安全时应为 20000</span><br></pre></td></tr></table></figure>
线程不安全：<br>原因： 多个线程对arrayList进行读写操作，出线了指令交错</li>
</ul>
</li>
<li><p>一个 ArrayList ，在添加一个元素的时候，它可能会有两步来完成：</p>
<ul>
<li>第一步: 在 arrayList[size]的位置存放此元素</li>
<li>第二步: size++</li>
</ul>
</li>
<li>在单线程运行的情况下，如果 size = 0，添加一个元素后，此元素在位置 0，而且 size=1；(没问题)</li>
<li>在多线程情况下，比如有两个线程，线程 A 先将元素存放在位置 0。但是此时 CPU 进行上下文切换 (线程A还没来得及size++)，线程 B 得到运行的机会。线程B也向此 ArrayList 添加元素，因为此时 Size 仍等于0 （注意哦，我们假设的是添加一个元素是要两个步骤哦，而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 size 的值。</li>
<li>那好，现在我们来看看 ArrayList 的情况，元素实际上只有一个，存放在位置 0，而 size 却等于 2。这就是“线程不安全”了。</li>
</ul>
<h2 id="4-Monitor"><a href="#4-Monitor" class="headerlink" title="4 Monitor"></a>4 Monitor</h2><h3 id="4-1-Java对象头"><a href="#4-1-Java对象头" class="headerlink" title="4.1 Java对象头"></a>4.1 Java对象头</h3><p>对象头包括两部分：运行时元数据（Mark Word）和类型指针（Klass Word）</p>
<ol>
<li>运行时元数据</li>
</ol>
<ol>
<li>类型指针</li>
</ol>
<ul>
<li>对于32位的虚拟机来说，普通对象的对象头如下：</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/25887408/1645858726347-eb2bd578-5722-4400-a21f-d0fd9a542c0a.png#clientId=u99690fde-e681-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=177&amp;id=uecc6c721&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=177&amp;originWidth=1036&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=25614&amp;status=done&amp;style=none&amp;taskId=ue004a4f1-1dbc-47e8-b080-aab5fd0285f&amp;title=&amp;width=1036" alt="image.png"></p>
<ul>
<li>数组对象的对象头另需要32位数据来存储数组的长度，对象头如下所示</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/25887408/1645858735119-27146ba3-fa0b-474b-a1a1-ae9cd69280bd.png#clientId=u99690fde-e681-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=184&amp;id=u5e945fa7&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=184&amp;originWidth=1043&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=38343&amp;status=done&amp;style=none&amp;taskId=ufcd35e84-e2d3-4e3a-9d5e-c9c9f88b5fc&amp;title=&amp;width=1043" alt="image.png"><br><strong>Mark Word的结构</strong></p>
<h3 id><a href="#" class="headerlink" title></a><img src="https://cdn.nlark.com/yuque/0/2022/png/25887408/1645859963854-19c93fcc-8c73-427d-bd1e-a1f59eedee07.png#clientId=u99690fde-e681-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=drop&amp;id=u2c135c76&amp;margin=%5Bobject%20Object%5D&amp;name=2022-02-26%2015-15-32%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png&amp;originHeight=441&amp;originWidth=1114&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=126275&amp;status=done&amp;style=none&amp;taskId=ua170595b-f174-45db-981f-b86562e1ac1&amp;title=" alt="2022-02-26 15-15-32屏幕截图.png"></h3><h3 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h3><h3 id="4-2-moniter原理"><a href="#4-2-moniter原理" class="headerlink" title="4.2 moniter原理"></a>4.2 moniter原理</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25887408/1645861959926-215f452f-dfb1-4501-b0a9-c9343a3941db.png#clientId=u99690fde-e681-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=drop&amp;id=uf7dcec49&amp;margin=%5Bobject%20Object%5D&amp;name=%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20%281%29.png&amp;originHeight=683&amp;originWidth=1641&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=191219&amp;status=done&amp;style=none&amp;taskId=u4c1987e2-7b7c-46f0-badd-caaaee455ee&amp;title=" alt="未命名文件 (1).png"></p>
<h2 id="5-synchronized原理"><a href="#5-synchronized原理" class="headerlink" title="5 synchronized原理"></a>5 synchronized原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SychronizedTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">0 getstatic #7 			  	&#x2F;&#x2F; 从常量池中获取锁对象lock</span><br><span class="line">3 dup													&#x2F;&#x2F; 复制一份锁对象</span><br><span class="line">4 astore_1			   			&#x2F;&#x2F; 将lock对象引用存储到 局部变量表slot_1处</span><br><span class="line">5 monitorenter    &#x2F;&#x2F; 将lock对象的Mark word设置为monitor指针</span><br><span class="line">6 getstatic #13      &#x2F;&#x2F; 执行临界区代码，从常量池中获取count</span><br><span class="line">9 iconst_1					   	&#x2F;&#x2F; 准备常数1</span><br><span class="line">10 iadd                 	&#x2F;&#x2F; 将count + 1</span><br><span class="line">11 putstatic #13 &#x2F;&#x2F; +1后的结果赋值给count</span><br><span class="line">14 aload_1					&#x2F;&#x2F; 将局部变量表slot_1中的变量即lock对象引用进栈</span><br><span class="line">15 monitorexit  &#x2F;&#x2F; 将lock对象Mark Word重置，唤醒EntryList</span><br><span class="line">16 goto 24 (+8)</span><br><span class="line">19 astore_2				 &#x2F;&#x2F; 下面为临界区代码出现异常时，锁对象lock的释放</span><br><span class="line">20 aload_1</span><br><span class="line">21 monitorexit</span><br><span class="line">22 aload_2</span><br><span class="line">23 athrow</span><br><span class="line">24 return</span><br></pre></td></tr></table></figure>
<h2 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h2><h2 id="-3"><a href="#-3" class="headerlink" title=" "></a> </h2><h2 id="-4"><a href="#-4" class="headerlink" title=" "></a> </h2><h2 id="6-wait-notify"><a href="#6-wait-notify" class="headerlink" title="6 wait-notify"></a>6 wait-notify</h2><h3 id="设计模式-保护性暂停​"><a href="#设计模式-保护性暂停​" class="headerlink" title="设计模式-保护性暂停​"></a>设计模式-保护性暂停​</h3><h2 id="7-park-unpark"><a href="#7-park-unpark" class="headerlink" title="7 park-unpark"></a>7 park-unpark</h2><h2 id="8-活跃性"><a href="#8-活跃性" class="headerlink" title="8 活跃性"></a>8 活跃性</h2><p><strong>定义：</strong> 由于某种原因使得代码一直无法执行，这样的现象叫做<strong>活跃性</strong><br>​</p>
<h3 id="多把锁"><a href="#多把锁" class="headerlink" title="多把锁"></a>多把锁</h3><p><strong>将锁的粒度细分</strong><br>​</p>
<ul>
<li>好处，是可以<code>增强并发度</code></li>
<li>坏处，如果一个线程需要同时获得多把锁，就<code>容易发生死锁</code></li>
</ul>
<h3 id="死锁-重点"><a href="#死锁-重点" class="headerlink" title="死锁 (重点)"></a>死锁 (<code>重点</code>)</h3><p>如果一个线程需要<code>同时获得多把锁</code>，就容易发生<strong>死锁</strong><br>​</p>
<p>下面的代码中，t1线程获得了A锁，然后t2线程获得了B锁，这是t1线程有尝试获得B锁，就等着t2释放锁；同时t2尝试获得A锁，等着t1释放锁；造成了t1，t2之间相互等着释放锁，此时就称为<strong>死锁</strong><br>​</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pubilc <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object A = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">final</span> Object B = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(A)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">synchronized</span>(B)&#123;</span><br><span class="line">                <span class="comment">// 临界区</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(B)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">synchronized</span>(A)&#123;</span><br><span class="line">                <span class="comment">// 临界区</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>未完成</p>
<h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><h2 id="-5"><a href="#-5" class="headerlink" title=" "></a> </h2><h2 id="9-ReentrantLock"><a href="#9-ReentrantLock" class="headerlink" title="9 ReentrantLock"></a>9 ReentrantLock</h2><h3 id="设计模式-顺序控制"><a href="#设计模式-顺序控制" class="headerlink" title="设计模式-顺序控制"></a>设计模式-顺序控制</h3><h2 id="10-ThreadLocal"><a href="#10-ThreadLocal" class="headerlink" title="10. ThreadLocal"></a>10. ThreadLocal</h2><h2 id="11-InheritableThreadLocal"><a href="#11-InheritableThreadLocal" class="headerlink" title="11.  InheritableThreadLocal"></a>11.  InheritableThreadLocal</h2><h1 id="3-内存"><a href="#3-内存" class="headerlink" title="3. 内存"></a>3. 内存</h1><h2 id="1-Java内存模型（JMM）"><a href="#1-Java内存模型（JMM）" class="headerlink" title="1. Java内存模型（JMM）"></a>1. Java内存模型（JMM）</h2><p>JMM: Java Memory Model, 从Java层面上定义了两个抽象概念即主存，工作内存；主存是线程共享的，工作内存是线程私有的，他们对应着计算机底层的CPU寄存器，缓存，硬件内存，CPU指令优化，让程序员直接面对底层是不友好的，所以从Java层面上抽象出了Java内存模型这一概念。<br>JMM的存在必要性直接体现先三个方面：原子性，可见性，有序性。</p>
<ul>
<li>原子性： 保证指令不受<strong>线程上下文切换的影响（synchronized, lock）</strong></li>
<li>可见性:    保证指令不受<strong>CPU缓存的影响</strong>，Java中即时编译器JIT对热点代码缓存优化<strong>（volatile）</strong></li>
<li><p>有序性:    保证指令不受<strong>CPU指令优化(</strong>指令重排<strong>)的影响（volatile）</strong></p>
<h2 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2. 可见性"></a>2. 可见性</h2><h3 id="2-1-退不出的循环"><a href="#2-1-退不出的循环" class="headerlink" title="2.1 退不出的循环"></a>2.1 退不出的循环</h3><p>下面的代码中，main线程将run修改为false，但t1线程无法停止，循环退不出去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_01MemoryModel</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(run)&#123;</span><br><span class="line">				<span class="comment">// run为真，循环一直执行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;runing...&quot;</span>);</span><br><span class="line">        run = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为什么无法退出循环</strong></p>
</li>
<li><p>初始状态， t线程刚开始从主内存(成员变量), 因为主线程sleep(1)秒, 这时候t1线程循环了好多次run的值, 超过了一定的阈值, JIT就会将主存中的run值读取到工作内存 (相当于缓存了一份, 不会去主存中读run的值了)。</p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/25887408/1642214996814-c6b5a5ee-c99d-423c-8961-48b8ffe2f3fe.png#clientId=u9056289c-c5a0-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ubc4f5a1e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=466&amp;originWidth=911&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=92588&amp;status=done&amp;style=none&amp;taskId=ub70bb62b-9771-4364-95c3-c9131352f61&amp;title=" alt="image.png"></p>
<ul>
<li>因为t线程频繁地从主存中读取run的值，JIT即时编译器会将run的值缓存至自己工作内存中的高速缓存中，减少对主存中run的访问以提高效率</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/25887408/1642215108762-e471863d-7b79-4340-842f-745ab6ffb35a.png#clientId=u9056289c-c5a0-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u429fd59a&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=445&amp;originWidth=1027&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=123894&amp;status=done&amp;style=none&amp;taskId=uc6a8324a-63b7-44fc-a252-e5a610a0642&amp;title=" alt="image.png"></p>
<ul>
<li>1 秒之后，main线程修改了run的值, 并同步至主存。而 t线程是从自己工作内存中的高速缓存中读取这个变量的值，<strong>结果永远是旧值</strong></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/25887408/1642215304238-e6049912-8b13-49e5-a7c6-1db57a71921d.png#clientId=u9056289c-c5a0-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u1abb3d14&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=439&amp;originWidth=1024&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=125571&amp;status=done&amp;style=none&amp;taskId=uc3939ebb-d5aa-4ce0-bf65-e04c9699ef3&amp;title=" alt="image.png"></p>
<h3 id="2-2-解决方法"><a href="#2-2-解决方法" class="headerlink" title="2.2 解决方法"></a>2.2 解决方法</h3><ol>
<li><strong>volatile关键字</strong></li>
</ol>
<p><strong>volitale</strong>用来修饰成员变量和静态成员变量(放在主存中的变量)，它可以避免线程从工作内存中查找变量的值，必须从主存中获取变量值，即线程操作volatile变量直接操作主存中的变量。<br>所以volatile可以保证代码块内部变量的可见性，但不可以保证代码块的原子性；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_01MemoryModel</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(run)&#123;</span><br><span class="line">				<span class="comment">// run为真，循环一直执行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;runing...&quot;</span>);</span><br><span class="line">        run = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>volatile 可以认为是一个轻量级的锁，被 volatile 修饰的变量，汇编指令会存在于一个”lock”的前缀。在CPU层面与主内存层面，通过缓存一致性协议，加锁后能够保证写的值同步到主内存，使其他线程能够获得最新的值。<br>volatile仅仅用在一个线程写，多个线程都的情况；如果涉及多个线程写的情况，就必须使用synchronized或者lock保证线程安全！</p>
<ol>
<li><strong>synchronized关键字</strong></li>
</ol>
<p><strong>synchronized</strong>关键字既可以保证代码块的原子性，又可以保证代码块内部变量的可见性；在Java内存模型中，synchronized规定，线程在加锁时，先清空工作内存→在主内存中拷贝最新变量的副本到工作内存 →执行完代码→将更改后的共享变量的值刷新到主内存中→释放互斥锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_01MemoryModel</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(run)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(_01MemoryModel.class)&#123;</span><br><span class="line">                	<span class="comment">// run为真，循环一直执行</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;runing...&quot;</span>);</span><br><span class="line">        run = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但是synchronized关键字属于重量级操作，性能相交volatile关键字较低；因此在只需要保证变量的可见性操作中，应优先考虑使用volatile关键字。</p>
<h3 id="2-3-两阶段终止模式优化"><a href="#2-3-两阶段终止模式优化" class="headerlink" title="2.3 两阶段终止模式优化"></a>2.3 两阶段终止模式优化</h3><h3 id="2-4-同步模式之犹豫模式"><a href="#2-4-同步模式之犹豫模式" class="headerlink" title="2.4 同步模式之犹豫模式"></a>2.4 同步模式之犹豫模式</h3><h2 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3. 有序性"></a>3. 有序性</h2><h2 id="4-内存屏障"><a href="#4-内存屏障" class="headerlink" title="4. 内存屏障"></a>4. 内存屏障</h2><h2 id="5-volatile原理"><a href="#5-volatile原理" class="headerlink" title="5. volatile原理"></a>5. volatile原理</h2><h2 id="-6"><a href="#-6" class="headerlink" title=" "></a> </h2><h1 id="4-无锁"><a href="#4-无锁" class="headerlink" title="4. 无锁"></a>4. 无锁</h1><h1 id="5-线程不可变"><a href="#5-线程不可变" class="headerlink" title="5. 线程不可变"></a>5. 线程不可变</h1><h1 id="6-线程池"><a href="#6-线程池" class="headerlink" title="6. 线程池"></a>6. 线程池</h1><p>池化技术   是一种常用的技术，比如线程池、数据库连接池、HTTP连接池等等都是使用了池化技术的思想。池化技术的思想是为了减少每次获取资源的消耗，提高对资源的利用率。<br>​</p>
<p>线程池的好处：</p>
<ol>
<li>降低资源消耗。通过重复利用已经创建好的线程来减少线程创建和销毁时带来的消耗。</li>
<li>提高响应速度。任务到达时，无须等待线程创创建就能立即执行任务</li>
<li>提高线程安全的可管理性。 线程是稀缺资源，无限制的创建线程资源，不仅会造成资源消耗，还会降低系统的稳定性，使用线程池进行统一的分配，调优和监控既可以避免线程无限制的创建。<h2 id="1-自己定义一个简单的线程池"><a href="#1-自己定义一个简单的线程池" class="headerlink" title="1. 自己定义一个简单的线程池"></a>1. 自己定义一个简单的线程池</h2><h3 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h3><img src="https://cdn.nlark.com/yuque/0/2022/png/25887408/1642752455226-9686f817-be47-4802-8236-940ae08116c8.png#clientId=uc4923773-e91c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=ui&amp;id=u9374c0a1&amp;margin=%5Bobject%20Object%5D&amp;name=%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20%282%29.png&amp;originHeight=1838&amp;originWidth=1544&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=382632&amp;status=done&amp;style=none&amp;taskId=u2df1a426-b05d-4f83-af24-b75df52c10f&amp;title=" alt="未命名文件 (2).png"></li>
</ol>
<ul>
<li>主线程：生产者，产生任务放入阻塞队列中</li>
<li>线程池：消费者，消费任务；获取阻塞队列中的任务并执行</li>
<li>阻塞队列：维护主线程中产生的任务；主线程生产任务放入阻塞队列里，线程池从阻塞队列中获取任务执行<h3 id="1-1-定义阻塞队列"><a href="#1-1-定义阻塞队列" class="headerlink" title="1.1 定义阻塞队列"></a>1.1 定义阻塞队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockingQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 定义任务队列</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;T&gt;();</span><br><span class="line">    <span class="comment">// 2. 声明锁</span></span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 3. 生产者条件变量(阻塞队列塞满任务时，没有空间进入，进入此条件变量中)</span></span><br><span class="line">    <span class="keyword">private</span> Condition fullWaitSet = lock.newCondition();</span><br><span class="line">    <span class="comment">// 4. 消费者条件变量(阻塞队列空时，没有任务可取，进入此条件变量中)</span></span><br><span class="line">    <span class="keyword">private</span> Condition emptyWaitSet = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 定义阻塞队列的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池从阻塞队列中获取任务，如果没有任务会一直等待</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 判断阻塞队列是否为空</span></span><br><span class="line">            <span class="keyword">while</span>(queue.isEmpty())&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;阻塞队列为空，等待新任务的产生...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    emptyWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 阻塞队列不为空，获取队列头部任务</span></span><br><span class="line">            T t = queue.removeFirst();</span><br><span class="line">            <span class="comment">// 队列中已有空间，唤醒生产者进行生产</span></span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他线程往阻塞队列中添加任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T task)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 判断阻塞队列是否已满</span></span><br><span class="line">            <span class="keyword">while</span>(queue.size() == capacity)&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;阻塞队列已满，等待加入阻塞队列&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fullWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 阻塞队列不满，往阻塞队列中添加任务</span></span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            log.debug(<span class="string">&quot;已往阻塞队列中加入任务&#123;&#125;&quot;</span>, task);</span><br><span class="line">            <span class="comment">// 队列中已有任务，唤醒消费者消费任务</span></span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> queue.size();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-定义线程池"><a href="#1-2-定义线程池" class="headerlink" title="1.2 定义线程池"></a>1.2 定义线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明阻塞任务队列</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明线程集合</span></span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> coreSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取任务的超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeOut;</span><br><span class="line">    <span class="comment">// 超时时间单位</span></span><br><span class="line">    <span class="keyword">private</span> TimeUnit timeUnit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">int</span> coreSize, <span class="keyword">long</span> timeOut, TimeUnit timeUnit, <span class="keyword">int</span> queueCapacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.taskQueue = <span class="keyword">new</span> BlockingQueue&lt;Runnable&gt;(queueCapacity);</span><br><span class="line">        <span class="keyword">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="keyword">this</span>.timeOut = timeOut;</span><br><span class="line">        <span class="keyword">this</span>.timeUnit = timeUnit;</span><br><span class="line"><span class="comment">//        this.rejectPolicy = rejectPolicy;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 工作线程数 &lt; 总线程数，worker可以执行这些任务，无须加入阻塞队列中</span></span><br><span class="line">        <span class="keyword">if</span>(workers.size() &lt; coreSize)&#123;</span><br><span class="line">            <span class="comment">// 创建线程</span></span><br><span class="line">            Worker worker = <span class="keyword">new</span> Worker(task);</span><br><span class="line">            log.debug(<span class="string">&quot;新增worker线程 &#123;&#125;， &#123;&#125;&quot;</span>, worker, task);</span><br><span class="line">            workers.add(worker);</span><br><span class="line">            worker.start();   <span class="comment">// 开启线程执行任务</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 线程数不够，加入阻塞队列</span></span><br><span class="line">            taskQueue.put(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池中的工作线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明线程要执行的任务</span></span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(Runnable task)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1. task不为null时，执行任务</span></span><br><span class="line"><span class="comment">             * 2. task为null时，从阻塞队列中取出任务并执行</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">while</span>(task != <span class="keyword">null</span> || (task = taskQueue.take()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;正在执行...&#123;&#125;&quot;</span>, task);</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 任务执行完毕，置为null</span></span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 任务执行完毕，将该线程移除</span></span><br><span class="line">            <span class="keyword">synchronized</span> (workers)&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;worker被移除 &#123;&#125;&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">                workers.remove(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-测试"><a href="#1-3-测试" class="headerlink" title="1.3 测试"></a>1.3 测试</h3>创建五个任务，由线程池的两个线程轮流来执行，阻塞队列可以容纳10个任务！<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestPool</span></span>&#123;</span><br><span class="line">    <span class="comment">// 任务生产者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ThreadPool threadPool = <span class="keyword">new</span> ThreadPool(<span class="number">2</span>, <span class="number">1</span>, TimeUnit.SECONDS, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 创建5个任务</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;正在执行任务&#123;&#125;...&quot;</span>, j);</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">正在创建第1个任务！！！</span><br><span class="line">15:39:04.532 h.ThreadPool [main] - 新增worker线程 0， _06线程池.TestPool$1@1ef7fe8e</span><br><span class="line">正在创建第2个任务！！！</span><br><span class="line">15:39:04.536 h.ThreadPool [main] - 新增worker线程 1， _06线程池.TestPool$1@50675690</span><br><span class="line">15:39:04.536 h.ThreadPool [线程0] - 正在执行..._06线程池.TestPool$1@1ef7fe8e</span><br><span class="line">15:39:04.536 h.TestPool [线程0] - 正在执行任务1...等待一秒...</span><br><span class="line">正在创建第3个任务！！！</span><br><span class="line">15:39:04.536 h.BlockingQueue [main] - 已往阻塞队列中加入任务_06线程池.TestPool$1@3ac42916</span><br><span class="line">正在创建第4个任务！！！</span><br><span class="line">15:39:04.536 h.ThreadPool [线程1] - 正在执行..._06线程池.TestPool$1@50675690</span><br><span class="line">15:39:04.536 h.TestPool [线程1] - 正在执行任务2...等待一秒...</span><br><span class="line">15:39:04.536 h.BlockingQueue [main] - 已往阻塞队列中加入任务_06线程池.TestPool$1@47d384ee</span><br><span class="line">正在创建第5个任务！！！</span><br><span class="line">15:39:04.536 h.BlockingQueue [main] - 已往阻塞队列中加入任务_06线程池.TestPool$1@2d6a9952</span><br><span class="line">15:39:05.537 h.TestPool [线程1] - 任务2执行完毕...</span><br><span class="line">15:39:05.537 h.TestPool [线程0] - 任务1执行完毕...</span><br><span class="line">15:39:05.537 h.ThreadPool [线程0] - 正在执行..._06线程池.TestPool$1@47d384ee</span><br><span class="line">15:39:05.537 h.TestPool [线程0] - 正在执行任务4...等待一秒...</span><br><span class="line">15:39:05.537 h.ThreadPool [线程1] - 正在执行..._06线程池.TestPool$1@3ac42916</span><br><span class="line">15:39:05.537 h.TestPool [线程1] - 正在执行任务3...等待一秒...</span><br><span class="line">15:39:06.537 h.TestPool [线程1] - 任务3执行完毕...</span><br><span class="line">15:39:06.537 h.TestPool [线程0] - 任务4执行完毕...</span><br><span class="line">15:39:06.537 h.ThreadPool [线程1] - 正在执行..._06线程池.TestPool$1@2d6a9952</span><br><span class="line">15:39:06.537 h.TestPool [线程1] - 正在执行任务5...等待一秒...</span><br><span class="line">15:39:06.537 h.BlockingQueue [线程0] - 阻塞队列为空，等待新任务的产生...</span><br><span class="line">15:39:07.537 h.TestPool [线程1] - 任务5执行完毕...</span><br><span class="line">15:39:07.537 h.BlockingQueue [线程1] - 阻塞队列为空，等待新任务的产生...</span><br><span class="line">...</span><br><span class="line">后面会一直死等，因为线程一直等待从阻塞队列中取任务</span><br></pre></td></tr></table></figure>
<h3 id="1-4-拒绝策略"><a href="#1-4-拒绝策略" class="headerlink" title="1.4 拒绝策略"></a>1.4 拒绝策略</h3>拒绝策略是指当阻塞队列已满时，核心线程的选择；在上面的逻辑中，当阻塞队列已满、核心线程都在工作时。新任务一直等待加入阻塞队列中；可以选择设置不同的状态，比如带超时时间等待、抛出异常等等；拒绝策略将状态的设置交给用户，使得线程池的功能更加丰富，扩展性更强！<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> <span class="comment">// 拒绝策略</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">RejectPolicy</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reject</span><span class="params">(BlockingQueue&lt;T&gt; queue, T task)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span></span>&#123;</span><br><span class="line">	<span class="comment">// 成员变量与上面一样</span></span><br><span class="line">    <span class="comment">//................</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">int</span> coreSize, <span class="keyword">long</span> timeOut, TimeUnit timeUnit, <span class="keyword">int</span> queueCapacity, RejectPolicy&lt;Runnable&gt; rejectPolicy)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.taskQueue = <span class="keyword">new</span> BlockingQueue&lt;Runnable&gt;(queueCapacity);</span><br><span class="line">        <span class="keyword">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="keyword">this</span>.timeOut = timeOut;</span><br><span class="line">        <span class="keyword">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="keyword">this</span>.rejectPolicy = rejectPolicy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 工作线程数 &lt; 总线程数，worker可以执行这些任务，无须加入阻塞队列中</span></span><br><span class="line">        <span class="keyword">if</span>(workers.size() &lt; coreSize)&#123;</span><br><span class="line">            <span class="comment">// 创建线程</span></span><br><span class="line">            Worker worker = <span class="keyword">new</span> Worker(task, <span class="string">&quot;线程&quot;</span> + workers.size());</span><br><span class="line">            log.debug(<span class="string">&quot;新增worker线程 &#123;&#125;， &#123;&#125;&quot;</span>, workers.size(), task);</span><br><span class="line">            workers.add(worker);</span><br><span class="line">            worker.start();   <span class="comment">// 开启线程执行任务</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 线程数不够，加入阻塞队列</span></span><br><span class="line"><span class="comment">//            taskQueue.put(task);</span></span><br><span class="line">            taskQueue.tryPut(rejectPolicy, task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池中的工作线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明线程要执行的任务</span></span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(Runnable task, String name)</span></span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1. task不为null时，执行任务</span></span><br><span class="line"><span class="comment">             * 2. task为null时，从阻塞队列中取出任务并执行</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">while</span>(task != <span class="keyword">null</span> || (task = taskQueue.poll(<span class="number">1000</span>, TimeUnit.MILLISECONDS)) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;正在执行...&#123;&#125;&quot;</span>, task);</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 任务执行完毕，置为null</span></span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 任务执行完毕，将该线程移除</span></span><br><span class="line">            <span class="keyword">synchronized</span> (workers)&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;worker被移除 &#123;&#125;&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">                workers.remove(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockingQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 定义任务队列</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 声明锁</span></span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 生产者条件变量(阻塞队列塞满任务时，没有空间进入，进入此条件变量中)</span></span><br><span class="line">    <span class="keyword">private</span> Condition fullWaitSet = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 消费者条件变量(阻塞队列空时，没有任务可取，进入此条件变量中)</span></span><br><span class="line">    <span class="keyword">private</span> Condition emptyWaitSet = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 定义阻塞队列的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带超时等待，获取阻塞队列中的任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit timeUnit)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">long</span> nanos = timeUnit.toNanos(timeout);</span><br><span class="line">            <span class="comment">// 判断阻塞队列是否为空</span></span><br><span class="line">            <span class="keyword">while</span>(queue.isEmpty())&#123;</span><br><span class="line">                <span class="comment">// 如果超时等待时间小于0，返回null</span></span><br><span class="line">                <span class="keyword">if</span>(nanos &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 返回时间 = 等待的时间 - 经过的时间，可以防止虚假唤醒</span></span><br><span class="line">                    nanos = emptyWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 阻塞队列不为空</span></span><br><span class="line">            T t = queue.removeFirst();</span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带超时时间，往阻塞队列中添加任务：阻塞队列一直为满，等待超时则放弃等待</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(T task, <span class="keyword">long</span> timeout, TimeUnit timeUnit)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">long</span> nanos = timeUnit.toNanos(timeout);</span><br><span class="line">            <span class="comment">// 阻塞队列已满</span></span><br><span class="line">            <span class="keyword">while</span>(queue.size() == capacity)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nanos &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 超时，放弃等待</span></span><br><span class="line">                    log.debug(<span class="string">&quot;已超时，放弃等待添加新任务...&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    nanos = fullWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 阻塞队列有空闲</span></span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyWaitSet.signal();   <span class="comment">// 唤醒阻塞队列空条件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tryPut</span><span class="params">(RejectPolicy&lt;T&gt; rejectPolicy, T task)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 阻塞队列已满</span></span><br><span class="line">            <span class="keyword">if</span>(queue.size() == capacity)&#123;</span><br><span class="line">                <span class="comment">// 根据拒绝策略选择线程等待阻塞队列中的任务方式</span></span><br><span class="line">                rejectPolicy.reject(<span class="keyword">this</span>, task);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 阻塞队列未满，可以继续添加任务</span></span><br><span class="line">                queue.addLast(task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
带拒绝策略测试<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPool threadPool = <span class="keyword">new</span> ThreadPool(<span class="number">1</span>,</span><br><span class="line">                <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="number">1</span>, (queue, task)-&gt;&#123;</span><br><span class="line">            <span class="comment">// 1. 死等</span></span><br><span class="line"><span class="comment">//            queue.put(task);</span></span><br><span class="line">            <span class="comment">// 2) 带超时等待</span></span><br><span class="line">            queue.offer(task, <span class="number">1500</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="comment">// 3) 让调用者放弃任务执行</span></span><br><span class="line"><span class="comment">//            log.debug(&quot;放弃&#123;&#125;&quot;, task);</span></span><br><span class="line">            <span class="comment">// 4) 让调用者抛出异常</span></span><br><span class="line"><span class="comment">//            throw new RuntimeException(&quot;任务执行失败 &quot; + task);</span></span><br><span class="line">            <span class="comment">// 5) 让调用者自己执行任务</span></span><br><span class="line"><span class="comment">//            task.run();</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, j);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-JDK中的线程池-ThreadPoolExexutor"><a href="#1-2-JDK中的线程池-ThreadPoolExexutor" class="headerlink" title="1.2 JDK中的线程池 ThreadPoolExexutor"></a>1.2 JDK中的线程池 ThreadPoolExexutor</h2><h3 id="1-线程池状态"><a href="#1-线程池状态" class="headerlink" title="1. 线程池状态"></a>1. 线程池状态</h3>ThreadPoolExexutor 使用int的高三位表示线程池状态，低29位表示线程数量</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>状态名称</strong></th>
<th><strong>高3位的值</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>RUNNING</td>
<td>111</td>
<td>接收新任务，同时处理任务队列中的任务</td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>000</td>
<td>不接受新任务，但是处理任务队列中的任务</td>
</tr>
<tr>
<td>STOP</td>
<td>001</td>
<td>中断正在执行的任务，同时抛弃阻塞队列中的任务</td>
</tr>
<tr>
<td>TIDYING</td>
<td>010</td>
<td>任务执行完毕，活动线程为0时，即将进入终结阶段</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>011</td>
<td>终结状态</td>
</tr>
</tbody>
</table>
</div>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Patterson</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://huangzheng1998.com/2021/11/25/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">http://huangzheng1998.com/2021/11/25/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B/">编程</a></div><div class="post_share"><div class="social-share" data-image="/imgcat/java.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/11/25/JavaVirtualMachine/"><img class="prev-cover" src="/imgcat/jvm.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Java虚拟机</div></div></a></div><div class="next-post pull-right"><a href="/2021/08/05/yoloutils/"><img class="next-cover" src="/imgcat/6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">目标检测-YOLO数据集里ImageSets与labels的建立</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2021/06/15/banlancetree/" title="数据结构-平衡二叉树"><img class="cover" src="/imgcat/ds.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-15</div><div class="title">数据结构-平衡二叉树</div></div></a></div><div><a href="/2021/06/30/bufferstream/" title="JavaSE-IO文件操作"><img class="cover" src="/imgcat/tom9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-30</div><div class="title">JavaSE-IO文件操作</div></div></a></div><div><a href="/2021/05/16/cn/" title="计算机网络-计算机网络概述"><img class="cover" src="/imgcat/cn.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-16</div><div class="title">计算机网络-计算机网络概述</div></div></a></div><div><a href="/2021/06/02/comuicate/" title="计算机网络-计网通信基础"><img class="cover" src="/imgcat/cn.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-02</div><div class="title">计算机网络-计网通信基础</div></div></a></div><div><a href="/2021/06/28/dag/" title="(待)数据结构-有向无环图-拓扑排序-关键路径"><img class="cover" src="/imgcat/graph.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-28</div><div class="title">(待)数据结构-有向无环图-拓扑排序-关键路径</div></div></a></div><div><a href="/2021/05/02/ds/" title="链表"><img class="cover" src="/imgcat/ds.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-02</div><div class="title">链表</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/b.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Patterson</div><div class="author-info__description">loyal Arsenal supporter, folk song & podcast lover, oral English amateur and coco-cola enthusiast</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">35</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">8</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huangzheng1998"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">抓住生活的每一个当下 用力的去感受</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">1. 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">1 多线程基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.</span> <span class="toc-text">2 多线程的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 继承Thread类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. 实现Runnable接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%9E%E7%8E%B0callable%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. 实现callable接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">3 线程运行原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">4 多线程方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#API"><span class="toc-number">1.4.1.</span> <span class="toc-text">API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#start-run"><span class="toc-number">1.4.2.</span> <span class="toc-text">start run</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep-yield-wait"><span class="toc-number">1.4.3.</span> <span class="toc-text">sleep  yield  wait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join"><span class="toc-number">1.4.4.</span> <span class="toc-text">join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interrupt"><span class="toc-number">1.4.5.</span> <span class="toc-text">interrupt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.4.6.</span> <span class="toc-text">线程优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.4.7.</span> <span class="toc-text">守护线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.5.</span> <span class="toc-text">5 线程状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%94%E7%A7%8D%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.5.1.</span> <span class="toc-text">操作系统五种线程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%85%AD%E7%A7%8D%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.5.2.</span> <span class="toc-text">Java六种线程状态</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E7%AE%A1%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">2.管程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">1 线程安全问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-synchronized"><span class="toc-number">2.2.</span> <span class="toc-text">2 synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-synchronized%E8%AF%AD%E6%B3%95"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1 synchronized语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-synchronized%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2 synchronized原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-synchronized%E5%8A%A0%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%8A"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.3 synchronized加在方法上</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90"><span class="toc-number">2.3.</span> <span class="toc-text">3 线程安全分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.1 成员变量与静态变量的线程安全分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.2 局部变量线程安全分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">2.3.3.</span> <span class="toc-text">3.3 线程安全的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">2.3.4.</span> <span class="toc-text">3.4 线程不安全的情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Monitor"><span class="toc-number">2.4.</span> <span class="toc-text">4 Monitor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Java%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-number">2.4.1.</span> <span class="toc-text">4.1 Java对象头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.4.2.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-1"><span class="toc-number">2.4.3.</span> <span class="toc-text"> </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-moniter%E5%8E%9F%E7%90%86"><span class="toc-number">2.4.4.</span> <span class="toc-text">4.2 moniter原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-synchronized%E5%8E%9F%E7%90%86"><span class="toc-number">2.5.</span> <span class="toc-text">5 synchronized原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-2"><span class="toc-number">2.6.</span> <span class="toc-text"> </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-3"><span class="toc-number">2.7.</span> <span class="toc-text"> </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-4"><span class="toc-number">2.8.</span> <span class="toc-text"> </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-wait-notify"><span class="toc-number">2.9.</span> <span class="toc-text">6 wait-notify</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C%E2%80%8B"><span class="toc-number">2.9.1.</span> <span class="toc-text">设计模式-保护性暂停​</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-park-unpark"><span class="toc-number">2.10.</span> <span class="toc-text">7 park-unpark</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%B4%BB%E8%B7%83%E6%80%A7"><span class="toc-number">2.11.</span> <span class="toc-text">8 活跃性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%8A%8A%E9%94%81"><span class="toc-number">2.11.1.</span> <span class="toc-text">多把锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81-%E9%87%8D%E7%82%B9"><span class="toc-number">2.11.2.</span> <span class="toc-text">死锁 (重点)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BB%E9%94%81"><span class="toc-number">2.11.3.</span> <span class="toc-text">活锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A5%A5%E9%A5%BF"><span class="toc-number">2.11.4.</span> <span class="toc-text">饥饿</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-5"><span class="toc-number">2.12.</span> <span class="toc-text"> </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-ReentrantLock"><span class="toc-number">2.13.</span> <span class="toc-text">9 ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">2.13.1.</span> <span class="toc-text">设计模式-顺序控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-ThreadLocal"><span class="toc-number">2.14.</span> <span class="toc-text">10. ThreadLocal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-InheritableThreadLocal"><span class="toc-number">2.15.</span> <span class="toc-text">11.  InheritableThreadLocal</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%86%85%E5%AD%98"><span class="toc-number">3.</span> <span class="toc-text">3. 内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88JMM%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">1. Java内存模型（JMM）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">3.2.</span> <span class="toc-text">2. 可见性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%80%80%E4%B8%8D%E5%87%BA%E7%9A%84%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.1 退不出的循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2 解决方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96"><span class="toc-number">3.2.3.</span> <span class="toc-text">2.3 两阶段终止模式优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B9%E8%B1%AB%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.4.</span> <span class="toc-text">2.4 同步模式之犹豫模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">3.3.</span> <span class="toc-text">3. 有序性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-number">3.4.</span> <span class="toc-text">4. 内存屏障</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-volatile%E5%8E%9F%E7%90%86"><span class="toc-number">3.5.</span> <span class="toc-text">5. volatile原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-6"><span class="toc-number">3.6.</span> <span class="toc-text"> </span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%97%A0%E9%94%81"><span class="toc-number">4.</span> <span class="toc-text">4. 无锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">5.</span> <span class="toc-text">5. 线程不可变</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">6.</span> <span class="toc-text">6. 线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%87%AA%E5%B7%B1%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">6.1.</span> <span class="toc-text">1. 自己定义一个简单的线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91"><span class="toc-number">6.1.1.</span> <span class="toc-text">代码逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%AE%9A%E4%B9%89%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">6.1.2.</span> <span class="toc-text">1.1 定义阻塞队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">6.1.3.</span> <span class="toc-text">1.2 定义线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%B5%8B%E8%AF%95"><span class="toc-number">6.1.4.</span> <span class="toc-text">1.3 测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-number">6.1.5.</span> <span class="toc-text">1.4 拒绝策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-JDK%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0-ThreadPoolExexutor"><span class="toc-number">6.2.</span> <span class="toc-text">1.2 JDK中的线程池 ThreadPoolExexutor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81"><span class="toc-number">6.2.1.</span> <span class="toc-text">1. 线程池状态</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/11/25/JavaVirtualMachine/" title="Java虚拟机"><img src="/imgcat/jvm.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java虚拟机"/></a><div class="content"><a class="title" href="/2021/11/25/JavaVirtualMachine/" title="Java虚拟机">Java虚拟机</a><time datetime="2021-11-25T11:31:20.000Z" title="Created 2021-11-25 19:31:20">2021-11-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/25/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="Java并发编程"><img src="/imgcat/java.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java并发编程"/></a><div class="content"><a class="title" href="/2021/11/25/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="Java并发编程">Java并发编程</a><time datetime="2021-11-25T11:31:20.000Z" title="Created 2021-11-25 19:31:20">2021-11-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/05/yoloutils/" title="目标检测-YOLO数据集里ImageSets与labels的建立"><img src="/imgcat/6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="目标检测-YOLO数据集里ImageSets与labels的建立"/></a><div class="content"><a class="title" href="/2021/08/05/yoloutils/" title="目标检测-YOLO数据集里ImageSets与labels的建立">目标检测-YOLO数据集里ImageSets与labels的建立</a><time datetime="2021-08-05T11:43:20.000Z" title="Created 2021-08-05 19:43:20">2021-08-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/28/mysql1/" title="MySQL-MySQL基础语法"><img src="/imgcat/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL-MySQL基础语法"/></a><div class="content"><a class="title" href="/2021/07/28/mysql1/" title="MySQL-MySQL基础语法">MySQL-MySQL基础语法</a><time datetime="2021-07-27T19:31:49.000Z" title="Created 2021-07-28 03:31:49">2021-07-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/15/javascript/" title="Javascript基础"><img src="/imgcat/tom9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Javascript基础"/></a><div class="content"><a class="title" href="/2021/07/15/javascript/" title="Javascript基础">Javascript基础</a><time datetime="2021-07-15T15:22:25.000Z" title="Created 2021-07-15 23:22:25">2021-07-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/imgcat/java.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Patterson</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="Increase font size"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="Decrease font size"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="3136952023" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener toc scroll 
  window.removeEventListener('scroll', window.tocScrollFn)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>